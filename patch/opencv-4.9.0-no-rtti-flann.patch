diff --color=auto -Nuarp opencv_orig/modules/flann/include/opencv2/flann/any.h opencv/modules/flann/include/opencv2/flann/any.h
--- opencv_orig/modules/flann/include/opencv2/flann/any.h	2024-05-27 13:06:32
+++ opencv/modules/flann/include/opencv2/flann/any.h	2024-05-27 01:33:56
@@ -24,34 +24,46 @@ namespace cvflann
 
 namespace cvflann
 {
-
+    struct any_type_info{
+        enum kind{
+            k_signed_char, k_unsigned_char, k_signed_short, k_unsigned_short,
+            k_signed_int, k_unsigned_int, k_signed_long, k_unsigned_long,
+            k_float, k_bool, k_double,
+            k_flann_centers_init_t,
+            k_flann_algorithm_t,
+            k_string_literal, k_string, k_empty, k_unknown
+        } type;
+        const char* fname;
+        const char* name() const { return fname;}
+    };
 namespace anyimpl
 {
 
-struct bad_any_cast : public std::exception
-{
-    bad_any_cast() = default;
+//struct bad_any_cast : public std::exception
+//{
+//    bad_any_cast() = default;
+//
+//    bad_any_cast(const char* src, const char* dst)
+//        : message_(cv::format("cvflann::bad_any_cast(from %s to %s)", src, dst)) {}
+//
+//
+//    const char* what() const noexcept override
+//    {
+//        return message_.c_str();
+//    }
+//
+//private:
+//    std::string message_{"cvflann::bad_any_cast"};
+//};
 
-    bad_any_cast(const char* src, const char* dst)
-        : message_(cv::format("cvflann::bad_any_cast(from %s to %s)", src, dst)) {}
+//#ifndef CV_THROW_IF_TYPE_MISMATCH
+//#define CV_THROW_IF_TYPE_MISMATCH(src_type_info, dst_type_info) \
+//    if ((src_type_info) != (dst_type_info)) \
+//        throw cvflann::anyimpl::bad_any_cast((src_type_info).name(), \
+//                                             (dst_type_info).name())
+//#endif
+#define CV_THROW_IF_TYPE_MISMATCH(...)
 
-
-    const char* what() const noexcept override
-    {
-        return message_.c_str();
-    }
-
-private:
-    std::string message_{"cvflann::bad_any_cast"};
-};
-
-#ifndef CV_THROW_IF_TYPE_MISMATCH
-#define CV_THROW_IF_TYPE_MISMATCH(src_type_info, dst_type_info) \
-    if ((src_type_info) != (dst_type_info)) \
-        throw cvflann::anyimpl::bad_any_cast((src_type_info).name(), \
-                                             (dst_type_info).name())
-#endif
-
 struct empty_any
 {
 };
@@ -62,6 +74,48 @@ inline std::ostream& operator <<(std::ostream& out, co
     return out;
 }
 
+
+template<typename T>
+inline  const any_type_info& any_typeid(){
+
+    static any_type_info t{any_type_info::k_unknown, "k_unknown"};
+    return t;
+}
+//const any_type_info& any_typeid() = delete;
+//    //static_assert(false, "bad specialization, please add type");
+//    static_assert (false, "T");
+//    static any_type_info t{any_type_info::k_bad, "bad"};
+//    return t;
+//}
+
+
+
+#define ANY_TYPEINFO(C_TYPE, ANY_KIND) \
+template<> \
+inline const any_type_info& any_typeid<C_TYPE>(){ \
+    static any_type_info t{ANY_KIND, #ANY_KIND}; \
+    return t; \
+}
+
+ANY_TYPEINFO(unsigned char,any_type_info::k_unsigned_char)
+ANY_TYPEINFO(signed char,any_type_info::k_signed_char )
+ANY_TYPEINFO(unsigned short,any_type_info::k_unsigned_short)
+ANY_TYPEINFO(signed short,any_type_info::k_signed_short)
+ANY_TYPEINFO(unsigned int,any_type_info::k_unsigned_int)
+ANY_TYPEINFO(signed int,any_type_info::k_signed_int)
+ANY_TYPEINFO(unsigned long,any_type_info::k_unsigned_long)
+ANY_TYPEINFO(signed long,any_type_info::k_signed_long)
+ANY_TYPEINFO(float,any_type_info::k_float)
+ANY_TYPEINFO(bool,any_type_info::k_bool)
+ANY_TYPEINFO(double,any_type_info::k_double)
+
+ANY_TYPEINFO(const char*,any_type_info::k_string_literal)
+ANY_TYPEINFO(std::string,any_type_info::k_string)
+ANY_TYPEINFO(empty_any,any_type_info::k_empty)
+ANY_TYPEINFO(flann_centers_init_t,any_type_info::k_flann_centers_init_t)
+ANY_TYPEINFO(flann_algorithm_t,any_type_info::k_flann_algorithm_t)
+
+
 struct base_any_policy
 {
     virtual void static_delete(void** x) = 0;
@@ -71,7 +125,8 @@ struct base_any_policy
     virtual void* get_value(void** src) = 0;
     virtual const void* get_value(void* const * src) = 0;
     virtual ::size_t get_size() = 0;
-    virtual const std::type_info& type() = 0;
+    //virtual const std::type_info& type() = 0;
+    virtual const any_type_info& type() = 0;
     virtual void print(std::ostream& out, void* const* src) = 0;
     virtual ~base_any_policy() {}
 };
@@ -80,7 +135,8 @@ struct typed_base_any_policy : base_any_policy
 struct typed_base_any_policy : base_any_policy
 {
     virtual ::size_t get_size() CV_OVERRIDE { return sizeof(T); }
-    virtual const std::type_info& type() CV_OVERRIDE { return typeid(T); }
+    //virtual const std::type_info& type() CV_OVERRIDE { return typeid(T); }
+    virtual const any_type_info& type() CV_OVERRIDE { return any_typeid<T>(); }
 
 };
 
@@ -311,7 +367,8 @@ struct any (public)
     /// Returns true if the any contains no value.
     bool empty() const
     {
-        return policy->type() == typeid(anyimpl::empty_any);
+        //return policy->type().type == typeid(anyimpl::empty_any);
+        return policy->type().type == any_type_info::k_empty;
     }
 
     /// Frees any allocated memory, and sets the value to NULL.
@@ -321,20 +378,20 @@ struct any (public)
         policy = anyimpl::SinglePolicy<anyimpl::empty_any>::get_policy();
     }
 
-    /// Returns true if the two types are the same.
-    bool compatible(const any& x) const
-    {
-        return policy->type() == x.policy->type();
-    }
+//    /// Returns true if the two types are the same.
+//    bool compatible(const any& x) const
+//    {
+//        return policy->type() == x.policy->type();
+//    }
 
-    /// Returns if the type is compatible with the policy
-    template<typename T>
-    bool has_type()
-    {
-        return policy->type() == typeid(T);
-    }
-
-    const std::type_info& type() const
+//    /// Returns if the type is compatible with the policy
+//    template<typename T>
+//    bool has_type()
+//    {
+//        return policy->type() == typeid(T);
+//    }
+//
+    const any_type_info& type() const
     {
         return policy->type();
     }
diff --color=auto -Nuarp opencv_orig/modules/flann/include/opencv2/flann/general.h opencv/modules/flann/include/opencv2/flann/general.h
--- opencv_orig/modules/flann/include/opencv2/flann/general.h	2024-05-27 13:06:32
+++ opencv/modules/flann/include/opencv2/flann/general.h	2024-05-25 15:50:34
@@ -33,7 +33,8 @@
 
 #include "opencv2/core/version.hpp"
 
-#if CV_VERSION_MAJOR <= 4
+//#if CV_VERSION_MAJOR <= 4
+#if 0
 
 //! @cond IGNORED
 
diff --color=auto -Nuarp opencv_orig/modules/flann/include/opencv2/flann/params.h opencv/modules/flann/include/opencv2/flann/params.h
--- opencv_orig/modules/flann/include/opencv2/flann/params.h	2024-05-27 13:06:32
+++ opencv/modules/flann/include/opencv2/flann/params.h	2024-05-25 15:50:34
@@ -76,12 +76,12 @@ T get_param(const IndexParams& params, const cv::Strin
 {
     IndexParams::const_iterator it = params.find(name);
     if (it != params.end()) {
-        try {
+//        try {
             return it->second.cast<T>();
-        } catch (const std::exception& e) {
-            CV_Error_(cv::Error::StsBadArg,
-                      ("FLANN '%s' param type mismatch: %s", name.c_str(), e.what()));
-        }
+//        } catch (const std::exception& e) {
+//            CV_Error_(cv::Error::StsBadArg,
+//                      ("FLANN '%s' param type mismatch: %s", name.c_str(), e.what()));
+//        }
     }
     else {
         return default_value;
@@ -93,12 +93,12 @@ T get_param(const IndexParams& params, const cv::Strin
 {
     IndexParams::const_iterator it = params.find(name);
     if (it != params.end()) {
-        try {
+//        try {
             return it->second.cast<T>();
-        } catch (const std::exception& e) {
-            CV_Error_(cv::Error::StsBadArg,
-                      ("FLANN '%s' param type mismatch: %s", name.c_str(), e.what()));
-        }
+//        } catch (const std::exception& e) {
+//            CV_Error_(cv::Error::StsBadArg,
+//                      ("FLANN '%s' param type mismatch: %s", name.c_str(), e.what()));
+//        }
     }
     else {
         FLANN_THROW(cv::Error::StsBadArg, cv::String("Missing parameter '")+name+cv::String("' in the parameters given"));
diff --color=auto -Nuarp opencv_orig/modules/flann/src/miniflann.cpp opencv/modules/flann/src/miniflann.cpp
--- opencv_orig/modules/flann/src/miniflann.cpp	2024-05-27 13:06:32
+++ opencv/modules/flann/src/miniflann.cpp	2024-05-25 15:50:34
@@ -104,90 +104,102 @@ void IndexParams::getAll(std::vector<String>& names,
     for( ; it != it_end; ++it )
     {
         names.push_back(it->first);
-        try
-        {
+        auto kind = it->second.type().type;
+        //try
+        if(kind==cvflann::any_type_info::k_string){
             String val = it->second.cast<String>();
             types.push_back(FLANN_INDEX_TYPE_STRING);
             strValues.push_back(val);
             numValues.push_back(-1);
         continue;
         }
-        catch (...) {}
+        //catch (...) {}
 
         strValues.push_back(it->second.type().name());
 
-        try
+        //try
+        if(kind==cvflann::any_type_info::k_double)
         {
             double val = it->second.cast<double>();
             types.push_back(FLANN_INDEX_TYPE_64F);
             numValues.push_back(val);
         continue;
         }
-        catch (...) {}
-        try
+        //catch (...) {}
+        //try
+
+        if(kind==cvflann::any_type_info::k_float)
         {
             float val = it->second.cast<float>();
             types.push_back(FLANN_INDEX_TYPE_32F);
             numValues.push_back(val);
         continue;
         }
-        catch (...) {}
-        try
+        //catch (...) {}
+        //try
+        if(kind==cvflann::any_type_info::k_signed_int)
         {
             int val = it->second.cast<int>();
             types.push_back(FLANN_INDEX_TYPE_32S);
             numValues.push_back(val);
         continue;
         }
-        catch (...) {}
-        try
+//        catch (...) {}
+//        try
+        if(kind==cvflann::any_type_info::k_signed_short)
         {
             short val = it->second.cast<short>();
             types.push_back(FLANN_INDEX_TYPE_16S);
             numValues.push_back(val);
         continue;
         }
-        catch (...) {}
-        try
+//        catch (...) {}
+//        try
+        if(kind==cvflann::any_type_info::k_unsigned_short)
         {
             ushort val = it->second.cast<ushort>();
             types.push_back(FLANN_INDEX_TYPE_16U);
             numValues.push_back(val);
         continue;
         }
-        catch (...) {}
-        try
+//        catch (...) {}
+//        try
+
+        if(kind==cvflann::any_type_info::k_signed_char)
         {
             char val = it->second.cast<char>();
             types.push_back(FLANN_INDEX_TYPE_8S);
             numValues.push_back(val);
         continue;
         }
-        catch (...) {}
-        try
+//        catch (...) {}
+//        try
+        if(kind==cvflann::any_type_info::k_unsigned_char)
         {
             uchar val = it->second.cast<uchar>();
             types.push_back(FLANN_INDEX_TYPE_8U);
             numValues.push_back(val);
         continue;
         }
-        catch (...) {}
-        try
+//        catch (...) {}
+//        try
+        if(kind==cvflann::any_type_info::k_bool)
         {
             bool val = it->second.cast<bool>();
             types.push_back(FLANN_INDEX_TYPE_BOOL);
             numValues.push_back(val);
         continue;
         }
-        catch (...) {}
-        try
+//        catch (...) {}
+//        try
+        if(kind==cvflann::any_type_info::k_flann_algorithm_t)
         {
             cvflann::flann_algorithm_t val = it->second.cast<cvflann::flann_algorithm_t>();
             types.push_back(FLANN_INDEX_TYPE_ALGORITHM);
             numValues.push_back(val);
         continue;
         }
-        catch (...) {}
+//        catch (...) {}
 
 
         types.push_back((FlannIndexType)-1); // unknown type
@@ -340,17 +352,17 @@ buildIndex_(void*& index, const Mat& data, const Index
     ::cvflann::Matrix<ElementType> dataset((ElementType*)data.data, data.rows, data.cols);
     IndexType* _index = new IndexType(dataset, get_params(params), dist);
 
-    try
-    {
+//    try
+//    {
         _index->buildIndex();
-    }
-    catch (...)
-    {
-        delete _index;
-        _index = NULL;
-
-        throw;
-    }
+//    }
+//    catch (...)
+//    {
+//        delete _index;
+//        _index = NULL;
+//
+//        throw;
+//    }
 
     index = _index;
 }
